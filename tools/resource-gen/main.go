package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"

	_ "github.com/apache/dubbo-kubernetes/api/mesh/v1alpha1"
	_ "github.com/apache/dubbo-kubernetes/api/system/v1alpha1"
	. "github.com/apache/dubbo-kubernetes/tools/resource-gen/genutils"
)

// resourceTemplate for creating a Dubbo Resource.
var resourceTemplate = template.Must(template.New("dubbo-resource").Parse(`
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by tools/resource-gen
// Run "make generate" to update this file.

{{ $pkg := printf "%sproto" .Package }}
{{ $tk := "` + "`" + `" }}

// nolint:whitespace
package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	{{ $pkg }} "github.com/apache/dubbo-kubernetes/api/{{ .Package }}/v1alpha1"
	coremodel "github.com/apache/dubbo-kubernetes/pkg/core/resource/model"
)

{{range .Resources}}

// +kubebuilder:object:root=true
{{- if .ScopeNamespace }}
// +kubebuilder:resource:categories=dubbo,scope=Namespaced
{{- else }}
// +kubebuilder:resource:categories=dubbo,scope=Cluster
{{- end}}
{{- range .AdditionalPrinterColumns }}
// +kubebuilder:printcolumn:{{ . }}
{{- end}}

const {{.ResourceType}}Kind = "{{.ResourceType}}"

type {{.ResourceType}} struct {
	metav1.TypeMeta   {{ $tk }}json:",inline"{{ $tk }}
	metav1.ObjectMeta {{ $tk }}json:"metadata,omitempty"{{ $tk }}

    // Mesh is the name of the dubbo mesh this resource belongs to.
	// It may be omitted for cluster-scoped resources.
	//
    // +kubebuilder:validation:Optional
	Mesh string {{ $tk }}json:"mesh,omitempty"{{ $tk }}

{{- if eq .ResourceType "DataplaneInsight" }}
	// Status is the status the dubbo resource.
    // +kubebuilder:validation:Optional
	Status   *apiextensionsv1.JSON {{ $tk }}json:"status,omitempty"{{ $tk }}
{{- else}}
	// Spec is the specification of the Dubbo {{ .ProtoType }} resource.
    // +kubebuilder:validation:Optional
	Spec   *{{$pkg}}.{{.ResourceType}} {{ $tk }}json:"spec,omitempty"{{ $tk }}
{{- end}}
	// Status is the status of the Dubbo {{.ResourceType}} resource.
	Status {{.ResourceType}}Status {{ $tk }}json:"status,omitempty"{{ $tk }}
}

type {{.ResourceType}}Status struct {
	// define resource-specific status here
}

// +kubebuilder:object:root=true
{{- if .ScopeNamespace }}
// +kubebuilder:resource:scope=Cluster
{{- else }}
// +kubebuilder:resource:scope=Namespaced
{{- end}}
type {{.ResourceType}}List struct {
	metav1.TypeMeta {{ $tk }}json:",inline"{{ $tk }}
	metav1.ListMeta {{ $tk }}json:"metadata,omitempty"{{ $tk }}
	Items           []{{.ResourceType}} {{ $tk }}json:"items"{{ $tk }}
}

func (r *{{.ResourceType}}) GetKind() string  {
	return r.Kind
}

func (r *{{.ResourceType}}) GetMesh() string {
	return r.Mesh
}

func (r *{{.ResourceType}}) SetMesh(mesh string) {
	r.Mesh = mesh
}

func (r *{{.ResourceType}}) GetResourceKey() string {
	return coremodel.BuildResourceKey(r.Mesh, r.Kind, r.Name)
}

func (r *{{.ResourceType}}) GetMeta() metav1.ObjectMeta {
	return r.ObjectMeta
}

func (r *{{.ResourceType}}) SetMeta(m metav1.ObjectMeta) {
	r.ObjectMeta = m
}

func (r *{{.ResourceType}}) GetSpec() coremodel.ResourceSpec {
	return r.Spec
}

func (r *{{.ResourceType}}) SetSpec(rs coremodel.ResourceSpec) error {
    if spec, ok := rs.(*{{ $pkg }}.{{.ResourceType}}); ok{
		r.Spec = spec
		return nil
	}
	return coremodel.ErrorInvalidItemType(r.Spec, rs)
}

{{- end }} {{/* Resources */}}
`))

// ProtoMessageFunc ...
type ProtoMessageFunc func(protoreflect.MessageType) bool

// OnDubboResourceMessage ...
func OnDubboResourceMessage(pkg string, f ProtoMessageFunc) ProtoMessageFunc {
	return func(m protoreflect.MessageType) bool {
		r := DubboResourceForMessage(m.Descriptor())
		if r == nil {
			return true
		}

		fullname := string(m.Descriptor().FullName())
		if strings.Contains(fullname, "legacy") {
			log.Printf("Skipping message: %s", fullname)
			return true
		}
		if r.Package == pkg {
			return f(m)
		}

		return true
	}
}

func main() {
	var pkg string
	var outputDir string

	flag.StringVar(&pkg, "package", "", "the name of the package to generate: (mesh, system)")
	flag.StringVar(&outputDir, "output", "", "the directory to write generated files")
	flag.Parse()

	switch pkg {
	case "mesh", "system":
	default:
		log.Fatalf("package %s is not supported", pkg)
	}

	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("failed to create output dir: %v", err)
	}

	var types []protoreflect.MessageType
	protoregistry.GlobalTypes.RangeMessages(
		OnDubboResourceMessage(pkg, func(m protoreflect.MessageType) bool {
			types = append(types, m)
			return true
		}))

	// Sort by name so the output is deterministic.
	sort.Slice(types, func(i, j int) bool {
		return types[i].Descriptor().FullName() < types[j].Descriptor().FullName()
	})

	var resources []ResourceInfo
	for _, t := range types {
		resourceInfo := ToResourceInfo(t.Descriptor())
		resources = append(resources, resourceInfo)
	}

	for _, resource := range resources {
		// 每次只传一个资源到模板中
		var buf bytes.Buffer
		if err := resourceTemplate.Execute(&buf, struct {
			Package   string
			Resources []ResourceInfo
		}{
			Package:   pkg,
			Resources: []ResourceInfo{resource}, // 只放一个资源
		}); err != nil {
			log.Fatalf("template error for %s: %s", resource.ResourceType, err)
		}

		out, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("format error for %s: %s", resource.ResourceType, err)
		}

		filename := filepath.Join(outputDir, fmt.Sprintf("%s_types.go", strings.ToLower(resource.ResourceType)))
		if err := os.WriteFile(filename, out, 0644); err != nil {
			log.Fatalf("write file error for %s: %s", filename, err)
		}

		log.Printf("Generated: %s", filename)
	}
}
