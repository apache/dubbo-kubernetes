// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: registry/v1alpha1/plugin_curation.proto

package registryv1alpha1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	PluginCurationService_ListCuratedPlugins_FullMethodName     = "/bufman.dubbo.apache.org.registry.v1alpha1.PluginCurationService/ListCuratedPlugins"
	PluginCurationService_CreateCuratedPlugin_FullMethodName    = "/bufman.dubbo.apache.org.registry.v1alpha1.PluginCurationService/CreateCuratedPlugin"
	PluginCurationService_GetLatestCuratedPlugin_FullMethodName = "/bufman.dubbo.apache.org.registry.v1alpha1.PluginCurationService/GetLatestCuratedPlugin"
	PluginCurationService_DeleteCuratedPlugin_FullMethodName    = "/bufman.dubbo.apache.org.registry.v1alpha1.PluginCurationService/DeleteCuratedPlugin"
)

// PluginCurationServiceClient is the client API for PluginCurationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginCurationServiceClient interface {
	// ListCuratedPlugins returns all the curated plugins available.
	ListCuratedPlugins(ctx context.Context, in *ListCuratedPluginsRequest, opts ...grpc.CallOption) (*ListCuratedPluginsResponse, error)
	// CreateCuratedPlugin creates a new curated plugin.
	CreateCuratedPlugin(ctx context.Context, in *CreateCuratedPluginRequest, opts ...grpc.CallOption) (*CreateCuratedPluginResponse, error)
	// GetLatestCuratedPlugin returns the latest version of a plugin matching given parameters.
	GetLatestCuratedPlugin(ctx context.Context, in *GetLatestCuratedPluginRequest, opts ...grpc.CallOption) (*GetLatestCuratedPluginResponse, error)
	// DeleteCuratedPlugin deletes a curated plugin based on the given parameters.
	DeleteCuratedPlugin(ctx context.Context, in *DeleteCuratedPluginRequest, opts ...grpc.CallOption) (*DeleteCuratedPluginResponse, error)
}

type pluginCurationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginCurationServiceClient(cc grpc.ClientConnInterface) PluginCurationServiceClient {
	return &pluginCurationServiceClient{cc}
}

func (c *pluginCurationServiceClient) ListCuratedPlugins(ctx context.Context, in *ListCuratedPluginsRequest, opts ...grpc.CallOption) (*ListCuratedPluginsResponse, error) {
	out := new(ListCuratedPluginsResponse)
	err := c.cc.Invoke(ctx, PluginCurationService_ListCuratedPlugins_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginCurationServiceClient) CreateCuratedPlugin(ctx context.Context, in *CreateCuratedPluginRequest, opts ...grpc.CallOption) (*CreateCuratedPluginResponse, error) {
	out := new(CreateCuratedPluginResponse)
	err := c.cc.Invoke(ctx, PluginCurationService_CreateCuratedPlugin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginCurationServiceClient) GetLatestCuratedPlugin(ctx context.Context, in *GetLatestCuratedPluginRequest, opts ...grpc.CallOption) (*GetLatestCuratedPluginResponse, error) {
	out := new(GetLatestCuratedPluginResponse)
	err := c.cc.Invoke(ctx, PluginCurationService_GetLatestCuratedPlugin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginCurationServiceClient) DeleteCuratedPlugin(ctx context.Context, in *DeleteCuratedPluginRequest, opts ...grpc.CallOption) (*DeleteCuratedPluginResponse, error) {
	out := new(DeleteCuratedPluginResponse)
	err := c.cc.Invoke(ctx, PluginCurationService_DeleteCuratedPlugin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginCurationServiceServer is the server API for PluginCurationService service.
// All implementations must embed UnimplementedPluginCurationServiceServer
// for forward compatibility
type PluginCurationServiceServer interface {
	// ListCuratedPlugins returns all the curated plugins available.
	ListCuratedPlugins(context.Context, *ListCuratedPluginsRequest) (*ListCuratedPluginsResponse, error)
	// CreateCuratedPlugin creates a new curated plugin.
	CreateCuratedPlugin(context.Context, *CreateCuratedPluginRequest) (*CreateCuratedPluginResponse, error)
	// GetLatestCuratedPlugin returns the latest version of a plugin matching given parameters.
	GetLatestCuratedPlugin(context.Context, *GetLatestCuratedPluginRequest) (*GetLatestCuratedPluginResponse, error)
	// DeleteCuratedPlugin deletes a curated plugin based on the given parameters.
	DeleteCuratedPlugin(context.Context, *DeleteCuratedPluginRequest) (*DeleteCuratedPluginResponse, error)
	mustEmbedUnimplementedPluginCurationServiceServer()
}

// UnimplementedPluginCurationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPluginCurationServiceServer struct {
}

func (UnimplementedPluginCurationServiceServer) ListCuratedPlugins(context.Context, *ListCuratedPluginsRequest) (*ListCuratedPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCuratedPlugins not implemented")
}
func (UnimplementedPluginCurationServiceServer) CreateCuratedPlugin(context.Context, *CreateCuratedPluginRequest) (*CreateCuratedPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCuratedPlugin not implemented")
}
func (UnimplementedPluginCurationServiceServer) GetLatestCuratedPlugin(context.Context, *GetLatestCuratedPluginRequest) (*GetLatestCuratedPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestCuratedPlugin not implemented")
}
func (UnimplementedPluginCurationServiceServer) DeleteCuratedPlugin(context.Context, *DeleteCuratedPluginRequest) (*DeleteCuratedPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCuratedPlugin not implemented")
}
func (UnimplementedPluginCurationServiceServer) mustEmbedUnimplementedPluginCurationServiceServer() {}

// UnsafePluginCurationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginCurationServiceServer will
// result in compilation errors.
type UnsafePluginCurationServiceServer interface {
	mustEmbedUnimplementedPluginCurationServiceServer()
}

func RegisterPluginCurationServiceServer(s grpc.ServiceRegistrar, srv PluginCurationServiceServer) {
	s.RegisterService(&PluginCurationService_ServiceDesc, srv)
}

func _PluginCurationService_ListCuratedPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCuratedPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginCurationServiceServer).ListCuratedPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginCurationService_ListCuratedPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginCurationServiceServer).ListCuratedPlugins(ctx, req.(*ListCuratedPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginCurationService_CreateCuratedPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCuratedPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginCurationServiceServer).CreateCuratedPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginCurationService_CreateCuratedPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginCurationServiceServer).CreateCuratedPlugin(ctx, req.(*CreateCuratedPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginCurationService_GetLatestCuratedPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestCuratedPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginCurationServiceServer).GetLatestCuratedPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginCurationService_GetLatestCuratedPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginCurationServiceServer).GetLatestCuratedPlugin(ctx, req.(*GetLatestCuratedPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginCurationService_DeleteCuratedPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCuratedPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginCurationServiceServer).DeleteCuratedPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginCurationService_DeleteCuratedPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginCurationServiceServer).DeleteCuratedPlugin(ctx, req.(*DeleteCuratedPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginCurationService_ServiceDesc is the grpc.ServiceDesc for PluginCurationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginCurationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bufman.dubbo.apache.org.registry.v1alpha1.PluginCurationService",
	HandlerType: (*PluginCurationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListCuratedPlugins",
			Handler:    _PluginCurationService_ListCuratedPlugins_Handler,
		},
		{
			MethodName: "CreateCuratedPlugin",
			Handler:    _PluginCurationService_CreateCuratedPlugin_Handler,
		},
		{
			MethodName: "GetLatestCuratedPlugin",
			Handler:    _PluginCurationService_GetLatestCuratedPlugin_Handler,
		},
		{
			MethodName: "DeleteCuratedPlugin",
			Handler:    _PluginCurationService_DeleteCuratedPlugin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "registry/v1alpha1/plugin_curation.proto",
}

const (
	CodeGenerationService_GenerateCode_FullMethodName = "/bufman.dubbo.apache.org.registry.v1alpha1.CodeGenerationService/GenerateCode"
)

// CodeGenerationServiceClient is the client API for CodeGenerationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CodeGenerationServiceClient interface {
	// GenerateCode generates code using the specified remote plugins.
	GenerateCode(ctx context.Context, in *GenerateCodeRequest, opts ...grpc.CallOption) (*GenerateCodeResponse, error)
}

type codeGenerationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCodeGenerationServiceClient(cc grpc.ClientConnInterface) CodeGenerationServiceClient {
	return &codeGenerationServiceClient{cc}
}

func (c *codeGenerationServiceClient) GenerateCode(ctx context.Context, in *GenerateCodeRequest, opts ...grpc.CallOption) (*GenerateCodeResponse, error) {
	out := new(GenerateCodeResponse)
	err := c.cc.Invoke(ctx, CodeGenerationService_GenerateCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CodeGenerationServiceServer is the server API for CodeGenerationService service.
// All implementations must embed UnimplementedCodeGenerationServiceServer
// for forward compatibility
type CodeGenerationServiceServer interface {
	// GenerateCode generates code using the specified remote plugins.
	GenerateCode(context.Context, *GenerateCodeRequest) (*GenerateCodeResponse, error)
	mustEmbedUnimplementedCodeGenerationServiceServer()
}

// UnimplementedCodeGenerationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCodeGenerationServiceServer struct {
}

func (UnimplementedCodeGenerationServiceServer) GenerateCode(context.Context, *GenerateCodeRequest) (*GenerateCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCode not implemented")
}
func (UnimplementedCodeGenerationServiceServer) mustEmbedUnimplementedCodeGenerationServiceServer() {}

// UnsafeCodeGenerationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CodeGenerationServiceServer will
// result in compilation errors.
type UnsafeCodeGenerationServiceServer interface {
	mustEmbedUnimplementedCodeGenerationServiceServer()
}

func RegisterCodeGenerationServiceServer(s grpc.ServiceRegistrar, srv CodeGenerationServiceServer) {
	s.RegisterService(&CodeGenerationService_ServiceDesc, srv)
}

func _CodeGenerationService_GenerateCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeGenerationServiceServer).GenerateCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeGenerationService_GenerateCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeGenerationServiceServer).GenerateCode(ctx, req.(*GenerateCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CodeGenerationService_ServiceDesc is the grpc.ServiceDesc for CodeGenerationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CodeGenerationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bufman.dubbo.apache.org.registry.v1alpha1.CodeGenerationService",
	HandlerType: (*CodeGenerationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateCode",
			Handler:    _CodeGenerationService_GenerateCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "registry/v1alpha1/plugin_curation.proto",
}
