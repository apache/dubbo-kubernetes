syntax = "proto3";

package dubbo.mesh.v1alpha1;

option go_package = "github.com/apache/dubbo-kubernetes/api/mesh/v1alpha1";

import "api/mesh/options.proto";
import "google/protobuf/wrappers.proto";
import "api/mesh/v1alpha1/selector.proto";
import "validate/validate.proto";

// TrafficRoute defines routing rules for the traffic in the mesh.
message TrafficRoute {

  option (dubbo.mesh.resource).name = "TrafficRouteResource";
  option (dubbo.mesh.resource).type = "TrafficRoute";
  option (dubbo.mesh.resource).package = "mesh";

  // List of selectors to match data plane proxies that are sources of traffic.
  repeated Selector sources = 1 [ (validate.rules).repeated .min_items = 1 ];

  // List of selectors to match services that are destinations of traffic.
  //
  // Notice the difference between sources and destinations.
  // While the source of traffic is always a data plane proxy within a mesh,
  // the destination is a service that could be either within or outside
  // of a mesh.
  repeated Selector destinations = 2
      [ (validate.rules).repeated .min_items = 1 ];

  // Split defines a destination with a weight assigned to it.
  message Split {

    // Weight assigned to that destination.
    // Weights are not percentages. For example two destinations with
    // weights the same weight "1" will receive both same amount of the traffic.
    // 0 means that the destination will be ignored.
    google.protobuf.UInt32Value weight = 1;

    // Selector to match individual endpoints that comprise that destination.
    //
    // Notice that an endpoint can be either inside or outside the mesh.
    // In the former case an endpoint corresponds to a data plane proxy,
    // in the latter case an endpoint is an External Service.
    map<string, string> destination = 2 [ (validate.rules).map = {
      min_pairs : 1,
      keys : {string : {min_len : 1}},
      values : {string : {min_len : 1}}
    } ];
  };

  // LoadBalancer defines the load balancing policy and configuration.
  message LoadBalancer {

    // RoundRobin is a simple policy in which each available upstream host is
    // selected in round robin order.
    message RoundRobin {}

    // LeastRequest uses different algorithms depending on whether hosts have
    // the same or different weights.
    message LeastRequest {
      // The number of random healthy hosts from which the host with the fewest
      // active requests will be chosen. Defaults to 2 so that we perform
      // two-choice selection if the field is not set.
      uint32 choice_count = 1;
    }

    // RingHash implements consistent hashing to upstream hosts.
    message RingHash {
      // The hash function used to hash hosts onto the ketama ring. The value
      // defaults to 'XX_HASH'.
      string hash_function = 1;

      // Minimum hash ring size.
      uint64 min_ring_size = 2;

      // Maximum hash ring size.
      uint64 max_ring_size = 3;
    }

    // Random selects a random available host.
    message Random {}

    // Maglev implements consistent hashing to upstream hosts.
    message Maglev {}

    oneof lb_type {
      RoundRobin round_robin = 1;
      LeastRequest least_request = 2;
      RingHash ring_hash = 3;
      Random random = 4;
      Maglev maglev = 5;
    }
  };

  // Conf defines the destination configuration.
  message Conf {
    // List of destinations with weights assigned to them.
    // When used, "destination" is not allowed.
    repeated Split split = 1 [ (validate.rules).repeated .min_items = 1 ];
    // Load balancer configuration for given "split" or "destination"
    LoadBalancer load_balancer = 2;
    // One destination that the traffic will be redirected to.
    // When used, "split" is not allowed.
    map<string, string> destination = 3;
  };

  // Configuration for the route.
  Conf conf = 3 [ (validate.rules).message.required = true ];
}
